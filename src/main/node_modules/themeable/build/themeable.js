"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.themeable = themeable;
exports.default = exports.SYMBOL = void 0;

var _isThemeable = _interopRequireDefault(require("./isThemeable"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _resolveFlair = _interopRequireDefault(require("./resolveFlair"));

var _resolveTheme = _interopRequireDefault(require("./resolveTheme"));

var _react = require("react");

var _presentable = require("presentable");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Licensed under the Apache License, Version 2.0 (the “License”); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an “AS IS” BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.
var SYMBOL = Symbol.for('themeable');
exports.SYMBOL = SYMBOL;

function decorateComponent(identifier) {
  return function (targetComponent) {
    // Modify the target component to enable support for presenters if necessary.
    if (!(0, _presentable.isPresentable)(targetComponent)) (0, _presentable.presentable)(targetComponent);
    var prototype = targetComponent.prototype; // Allow the identifier to be modified without affecting an already themeable
    // component.

    prototype.getThemeableIdentifier = function () {
      var _identifier;

      return (_identifier = identifier) !== null && _identifier !== void 0 ? _identifier : prototype.constructor.name;
    };

    if ((0, _isThemeable.default)(targetComponent)) return targetComponent; // The theme attribute in the context will be defined by the “ContextTheme”
    // component.

    if (!targetComponent.contextTypes) targetComponent.contextTypes = {};
    targetComponent.contextTypes.theme = _propTypes.default.object; // Marker used to detect if the component is themeable.

    Object.defineProperty(prototype, SYMBOL, {
      get: function get() {
        return true;
      }
    }); // Used to combine the presentable’s data with the new attributes from the
    // themeable logic.

    var oldGetPresentableData = prototype.getPresentableData; // Combine presentable data with themeable data.

    prototype.getPresentableData = function () {
      var result = oldGetPresentableData.call(this);
      var RESOLVED_THEME = (0, _resolveTheme.default)(this);
      var RESOLVED_FLAIR = (0, _resolveFlair.default)(this, RESOLVED_THEME);

      if (RESOLVED_FLAIR) {
        var flair = RESOLVED_FLAIR.flair;
        var className = result.props.className;

        if (flair) {
          result.props.className = className ? "".concat(className, " ").concat(flair) : flair;
        }
      }

      delete result.props.flair;
      delete result.props.theme;
      return result;
    }; // The final component with theming support.


    return targetComponent;
  };
}
/**
 * Enables theming support for a ReactJS component.
 *
 * @param identifierOrComponent
 * A unique identifier used to select the “ComponentTheme” inside the “Theme” or
 * the component to enable theming. If the component has no identifier, it’ll
 * only support themes passed directly to it.
 */


function themeable(identifierOrComponent
/*:string|Class<Component<*>>*/
) {
  // It’s a component.
  if (identifierOrComponent && identifierOrComponent.prototype instanceof _react.Component) return decorateComponent()(identifierOrComponent); // It’s an identifier or bogus identifier.

  return decorateComponent(identifierOrComponent);
}

var _default = themeable;
exports.default = _default;
//# sourceMappingURL=themeable.js.map